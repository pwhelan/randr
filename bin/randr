#!/usr/bin/env php
<?php

/*
$APP_INCLUDE = getenv('APP_INCLUDE');
$QUEUE = getenv('QUEUE');

$REDIS_BACKEND = getenv('REDIS_BACKEND');
$REDIS_DATABASE = getenv('REDIS_DATABASE');
$REDIS_NAMESPACE = getenv('REDIS_NAMESPACE');

$logLevel = Resque_Worker::LOG_NONE;
$LOGGING = getenv('LOGGING');
$VERBOSE = getenv('VERBOSE');
$VVERBOSE = getenv('VVERBOSE');
if (!empty($LOGGING) || !empty($VERBOSE)) {
	$logLevel = Resque_Worker::LOG_NORMAL;
} elseif (!empty($VVERBOSE)) {
	$logLevel = Resque_Worker::LOG_VERBOSE;
}

$interval = 5;
$INTERVAL = getenv('INTERVAL');
if (!empty($INTERVAL)) {
	$interval = $INTERVAL;
}

$count = 1;
$COUNT = getenv('COUNT');
if (!empty($COUNT) && $COUNT > 1) {
	$count = $COUNT;
}

startWorker($QUEUE, $logLevel, $logger, $interval);

function startWorker($QUEUE, $logLevel, $logger, $interval)
{
	$queues = explode(',', $QUEUE);
	$worker = new Resque_Worker($queues);
	$worker->registerLogger($logger);
	$worker->logLevel = $logLevel;
	$worker->work($interval);
}
*/
use React\Promise;
use React\Stream;

use Clue\React\Redis\Client;
use Clue\React\Redis\Factory;

use Illuminate\Support\Collection;

require_once __DIR__.'/../vendor/autoload.php';


global $loop;

$loop = React\EventLoop\Factory::create();
$factory = new Factory($loop);

$queues = ["foo[4]", "bar[2:15]"];


class FakeAsyncResqueRedis //extends Resque_Redis
{
	private $client;
	
	/**
	* Redis namespace
	* @var string
	*/
	private static $defaultNamespace = 'resque:';
	
	/**
	* @var array List of all commands in Redis that supply a key as their
	*	first argument. Used to prefix keys with the Resque namespace.
	*/
	private $keyCommands = array(
		'exists',
		'del',
		'type',
		'keys',
		'expire',
		'ttl',
		'move',
		'set',
		'get',
		'getset',
		'setnx',
		'incr',
		'incrby',
		'decr',
		'decrby',
		'rpush',
		'lpush',
		'llen',
		'lrange',
		'ltrim',
		'lindex',
		'lset',
		'lrem',
		'lpop',
		'rpop',
		'sadd',
		'srem',
		'spop',
		'scard',
		'sismember',
		'smembers',
		'srandmember',
		'zadd',
		'zrem',
		'zrange',
		'zrevrange',
		'zrangebyscore',
		'zcard',
		'zscore',
		'zremrangebyscore',
		'sort'
	);
	// sinterstore
	// sunion
	// sunionstore
	// sdiff
	// sdiffstore
	// sinter
	// smove
	// rename
	// rpoplpush
	// mget
	// msetnx
	// mset
	// renamenx
	
	/**
	* Set Redis namespace (prefix) default: resque
	* @param string $namespace
	*/
	public function prefix($namespace)
	{
		if (strpos($namespace, ':') === false) {
			$namespace .= ':';
		}
		self::$defaultNamespace = $namespace;
	}

	/**
	* Magic method to handle all function requests and prefix key based
	* operations with the {self::$defaultNamespace} key prefix.
	*
	* @param string $name The name of the method called.
	* @param array $args Array of supplied arguments to the method.
	* @return mixed Return value from Resident::call() based on the command.
	*/
	public function __call($name, $args)
	{
		$args = func_get_args();
		if(in_array($name, $this->keyCommands)) {
			$args[1][0] = self::$defaultNamespace . $args[1][0];
		}
		try {
			return call_user_func_array([$this->client, $name], $args[1]);
		}
		catch(Exception $e) {
			return false;
		}
	}
	
	public function __construct(Client $client)
	{
		$this->client = $client;
	}
	
}

class Context extends ArrayObject
{
	public function __construct($props)
	{
		parent::__construct($props, ArrayObject::ARRAY_AS_PROPS);
	}
	
	public function __call($func, $args)
	{
		if (isset($this->$func))
		{
			return call_user_func_array($this->$func, $args);
		}
	}
}

$factory->createClient()
	->then(function (Client $client) {
		$deferred = new Promise\Deferred;
		
		$client->select(0)
			->then(function() use ($deferred, $client) {
				$deferred->resolve($client);
			});
		
		return $deferred->promise();
	})
	->then(function (Client $client) use ($loop, $queues) {
		
		Resque::$redis = new FakeAsyncResqueRedis($client);
		Resque::$pid = getmypid();
		
		$context = new Context([
			'process'	=> null,
			'client'	=> $client,
			'queues'	=> Collection::make(array_map(
				function($queue) {
					
					$m = preg_match("/([a-zA-Z]+)(?:\\[(\\d+)(?:|\\:\\d+))\\]/u", $queue, $matches);
					if (!$m) {
						die("Bad Queue: ".$queue);
					}
					
					$name		= $matches[1];
					$workers	= count($matches) >= 3 ? $matches[2] : 1;
					$intval		= count($matches) >= 4 ? $matches[3] : 0;
					
					return (object)[
						'name'		=> $name,
						'interval'	=> $intval,
						'workers'	=> (object)[
							'max'	=> $workers,
							'cur'	=> 0,
							'total'	=> 0,
							'failed'=> 0
						]
					];
				},
				is_array($queues) ? $queues : explode(',', $queues)
			)),
			'worker'	=> null
		]);
		
		$wp = new Randr\Worker\Pool($loop, $context->queues);
		
		$context->worker = new Resque_Worker($context->queues->lists('name'));
		$context->worker->registerWorker();
		
		$listQueues = function() use ($context) {
			print "QUEUES:\n";
			foreach ($context->queues->toArray() as $q) {
				print "\t[ ] {$q->name} {$q->workers->cur} => {$q->workers->max} [{$q->workers->total}]\n";
			}
		};
		
		$pcntl = new MKraemer\ReactPCNTL\PCNTL($loop);
		$pcntl->on(SIGHUP, $listQueues);
		
		
		$context->process = function() use ($context, $loop, $wp)
		{
			$args = $context->queues
				->filter(function($queue) {
					return $queue->workers->cur < $queue->workers->max;
				})
				->lists('name');
			
			if (count($args) <= 0)
			{
				$loop->addTimer(1, function() use ($context) {
					$context->process();
				});
				return;
			}
			
			$args[] = 5;
			
			
			$promise = call_user_func_array([$context->client, 'blpop'], $args);
			
			$promise->then(function($resp) use ($context, $wp) {
				try
				{
					if ($resp)
					{
						list($qname, $payload) = $resp;
						
						
						$queue = $context->queues
							->filter(function($queue) use ($qname) {
								return $queue->name == $qname;
							})
							->first();
						
						$job = new Randr\Job($queue->name, json_decode($payload, true));
						$child = $wp->run($job);
						
						$child->once('exit', function() use ($queue) {
							$queue->workers->cur--;
						});
						
						$child->once('fail', function() use ($queue) {
							$queue->workers->failed++;
						});
						
						$queue->workers->total++;
						$queue->workers->cur++;
					}
				}
				catch (Exception $e)
				{
					
				}
				
				$context->process();
			});
		};
		
		$context->process();
	});

class TestWorker
{
	public function perform()
	{
		print "TESTING IN ".getmypid()." .....\n";
		print "TEST IS SUCCESFUL FOR {$this->queue}\n";
	}
}

$loop->run();
